#ifndef COGNITION_RECOGNIZER_EIGENFACERECOGNIZER_H
#define COGNITION_RECOGNIZER_EIGENFACERECOGNIZER_H

//Implementation based on http://www.cognotics.com/opencv/servo_2007_series/part_5/index.html
//by Robin Hewitt, many thanks for his great articles

//suppress warinings generated by the cvaux library that this class uses
#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_WARNINGS 

#include <map>
#include <opencv2/core/core.hpp>
#include "../recognizer.h"
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/highgui/highgui.hpp>

namespace cognition
{

	/*!
	 * \brief Implementation of the Eigenface face recognition algorithm
	 *		  it uses old style C functions of the OpenCV library, based on
	 *		  http://www.cognotics.com/opencv/servo_2007_series/part_5/index.html
	 *		  by Robin Hewitt.
	 *
	 * \todo  upgrade internals to the OpenCV C++ api (cv::Mat and cv::PCA)
	 * \author Christophe Hesters 29-1-2011
	 */
	class EigenfaceRecognizer : public Recognizer
	{
	public:
		EigenfaceRecognizer(void);
		virtual ~EigenfaceRecognizer(void);

		/*!
		 * \brief Adds a training image path to the training set of known images
		 *		  after you have added 2 or more images, call train to learn and
		 *		  set yourself up for recognition. All images must be the same size!
		 *		  
		 * \note warning! method does not check if the filename exists and the application
		 *		  can crash if it does not exist! this check should be added (in train?)!
		 * 
		 * \param filename	the path where to find the image (all of the same size!)
		 * \param name		the name you want to attach to the image
		 * \return bool		true if the path is added succesfully
		 */
		bool addTrainingImage(const std::string &filename, const std::string &name);
		
		/*!
		 * \brief starts the learning process on all the known images that
		 *		  are added trough addTrainingImage. You can add more training images
		 *		  after training, but you have to call train again. While training
		 *		  you cannot use recognize()! 
		 *
		 * \note make sure all image paths exist
		 * 
		 * \return bool		true if trained, false otherwise
		 */
		bool train();

		/*!
		 * \brief does recognition on the face, and returns the most likely match. 
		 *		  This face must grayscale and be exactly the same size as the training
		 *		  images.
		 * 
		 * \param face		the matrix containing the face
		 * \return string	name of closest match in the set of training images
		 */
		std::string recognize(cv::Mat &face);

		/*!
		 * \brief does recognition on the face, and returns the most likely match. 
		 *		  This face must grayscale and be exactly the same size as the training
		 *		  images.
		 * 
		 * \return size_t	the number of registered training images
		 */
		std::size_t numTrainingImages(){ return trainingImages.size(); }

	protected:

		bool loadTrainingImages();
		//principal component analysis
		void doPCA();
		void freeMemory(int fromIndex = -1);
		int findNearestNeighbor(float *projectedTestImage);

		typedef std::map<std::string, std::string> StringMap;
	
		//filename - > name
		StringMap trainingImages;
	
		//index - > filename,name (since trainingImages can change) 
		typedef std::pair<std::string, std::string> StringPair;
		std::vector<StringPair> recognitionDescriptor;
	
		IplImage **images;			//array of trained images
		int numTrainedImages;		//number of training images used
		int numEigenvalues;			//number of eigenvalues
		IplImage **eigenVectors;	//array of eigenvectors
		IplImage *averageImage;		//the average image of the training set
		CvMat *eigenvalues;			//eigenvalues matrix
		CvMat *projectedTrainImage;	//projected image matrix	
	};

}
#endif //COGNITION_RECOGNIZER_EIGENFACERECOGNIZER_H
